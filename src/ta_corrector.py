# ta_corrector.py

# قائمة الكلمات التي يحدث فيها التناوب (التي يجب تحليلها)
# الكلمات التي يجب أن تكون التاء فيها مفتوحة إذا تحقق شرط التعيين
TA_WORDS = [
    "رحمة", "نعمة", "سنة", "لعنة", "امرأة", "معصية",
    "فطرة", "بقية", "كلمة", "شجرة", "قرة", "جنة",
    "آية", "بينة", "ثمرة", "غيابة", "جمالة"
]

# قائمة بأسماء المعرفة أو الضمائر التي تُنشئ التعيين
DEFINITE_NOUNS = ["الله", "ربك", "الرسول", "نوح", "لوط", "فرعون", "عمران", "العزيز"]

# قائمة بالأفعال التي تفرض التعيين الدلالي (الجزئي أو النوعي)
DESIGNATION_VERBS = ["تعدوا", "يرجون", "تجد", "ينظروا"]


def apply_semantic_ta_correction(text: str) -> str:
    """
    يطبق طبقة التصحيح الدلالي لتاء التأنيث في الأسماء المفردة.

    Args:
        text (str): النص المراد تصحيحه (يفترض أنه نص قرآني أو عربي فصيح).

    Returns:
        str: النص المصحح وفقاً لقاعدة التعيين الدلالي.
    """
    
    # تقسيم النص إلى كلمات لتسهيل تحليل السياق
    words = text.split()
    corrected_words = []
    
    # تكرار على كل كلمة في النص مع الاحتفاظ بموقعها (index)
    for i, word in enumerate(words):
        # تجريد الكلمة من التاء المربوطة والمفتوحة للتحقق من الأصل
        # نستخدم دالة "strip" بسيطة لأغراض العرض
        clean_word = word.strip("ةت") 
        
        # 1. فحص هل الكلمة هي من الكلمات التي يحدث فيها التناوب
        if clean_word in [w.strip("ة") for w in TA_WORDS]:
            
            # افتراض أن الأصل هو التاء المربوطة (العموم/ة)
            correction = clean_word + "ة" 
            
            # --- آليات الكشف عن التعيين (التي توجب التاء المفتوحة 'ت') ---
            
            # الآلية 1: الكشف عن التعيين النحوي الصريح (Idafa)
            # إذا كانت الكلمة التالية هي اسم معرفة أو لفظ الجلالة
            if i + 1 < len(words) and words[i+1].strip(",").strip(".").strip(" ") in DEFINITE_NOUNS:
                correction = clean_word + "ت"
                
            # الآلية 2: الكشف عن التعيين الدلالي بالتعليق (الوصف والسياق)
            # هذه الآلية تحتاج لذكاء أكبر، لكننا نستخدم هنا مفاتيح سياقية بسيطة:
            elif "روح" in words or "ريحان" in words:  # حالة "جنة نعيم" (فروح وريحان)
                if clean_word == "جنة":
                    correction = clean_word + "ت"
            
            # الآلية 3: الكشف عن التعيين النوعي/الفِعلي (Action-Based)
            # البحث عن فعل يفرض التخصيص في مكان ما قبل الكلمة
            for j in range(max(0, i - 4), i): # البحث في الـ 4 كلمات السابقة
                if words[j].strip(",").strip(".") in DESIGNATION_VERBS:
                    if clean_word == "نعمة" or clean_word == "رحمة": # مثال على التخصيص بالفعل
                        correction = clean_word + "ت"
                        break
            
            # -----------------------------------------------------------
            
            # إذا وجدنا تعييناً، نقوم بالتصحيح
            if correction.endswith("ت"):
                # نحتفظ بالتشكيل أو الإضافة الأصلية إذا كانت موجودة (لأغراض العرض)
                corrected_word = clean_word + "ت" 
            else:
                corrected_word = clean_word + "ة"
            
            # إضافة الكلمة المصححة إلى القائمة النهائية
            corrected_words.append(corrected_word)
        
        else:
            # إذا لم تكن الكلمة من الكلمات الـ 17، نضيفها كما هي
            corrected_words.append(word)

    # إعادة تجميع الكلمات المصححة في نص واحد
    return " ".join(corrected_words)

# ----------------------------------------------------------------------
# أمثلة اختبار بسيطة (يمكنك إضافتها في ملف ai_integration_demo.py)
# ----------------------------------------------------------------------

# 1. اختبار الإضافة الصريحة (الآلية 1)
text1 = "امرأة عمران كانت صالحة"
# print(f"النتيجة المتوقعة: إمرأت")

# 2. اختبار الوصف السابق (الآلية 2)
text2 = "فروح وريحان و جنة نعيم"
# print(f"النتيجة المتوقعة: جنت")

# 3. اختبار التعيين بالفعل (الآلية 3)
text3 = "ان تعدوا نعمة الله لا تحصوها"
# print(f"النتيجة المتوقعة: نعمت")

# text4 = "أولئك يرجون رحمة الله"
# print(f"النتيجة المتوقعة: رحمت")
